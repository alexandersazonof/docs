---
title: Debugging de Subgraphs Rápido e Fácil Com Forks
---

As with many systems processing large amounts of data, The Graph's Indexers (Graph Nodes) may take quite some time to sync-up your subgraph with the target blockchain. The discrepancy between quick changes with the purpose of debugging and long wait times needed for indexing is extremely counterproductive and we are well aware of that. This is why we are introducing **subgraph forking**, developed by [LimeChain](https://limechain.tech/), and in this article I will show you how this feature can be used to substantially speed-up subgraph debugging!

## Ok, o que é isso?

**Subgraph forking** é o processo de retirar entidades tranquilamente do armazenamento de _outro_ subgraph (sendo muitas vezes remoto).

No contexto do debugging, o **subgraph forking** permite debugar o seu subgraph falho no bloco _X_ sem precisar esperar que ele sincronize até o bloco _X_.

## O quê?! Como?!

When you deploy a subgraph to a remote Graph Node for indexing and it fails at block _X_, the good news is that the Graph Node will still serve GraphQL queries using its store, which is synced-up to block _X_. That's great! This means we can take advantage of this "up-to-date" store to fix the bugs arising when indexing block _X_.

In a nutshell, we are going to _fork the failing subgraph_ from a remote Graph Node that is guaranteed to have the subgraph indexed up to block _X_ in order to provide the locally deployed subgraph being debugged at block _X_ an up-to-date view of the indexing state.

## Por favor, quero ver códigos!

Para manter o foco no debugging dos subgraphs, vamos simplificar as coisas e seguir o [exemplo de subgraph](https://github.com/graphprotocol/graph-tooling/tree/main/examples/ethereum-gravatar) com a indexação do contrato inteligente do Ethereum Gravity.

Aqui estão os handlers definidos para o indexamento dos `Gravatar`s, sem qualquer bug:

```tsx
export function handleNewGravatar(event: NewGravatar): void {
  let gravatar = new Gravatar(event.params.id.toHex().toString())
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}

export function handleUpdatedGravatar(event: UpdatedGravatar): void {
  let gravatar = Gravatar.load(event.params.id.toI32().toString())
  if (gravatar == null) {
    log.critical('Gravatar not found!', [])
    return
  }
  gravatar.owner = event.params.owner
  gravatar.displayName = event.params.displayName
  gravatar.imageUrl = event.params.imageUrl
  gravatar.save()
}
```

Oops, how unfortunate, when I deploy my perfect looking subgraph to [Subgraph Studio](https://thegraph.com/studio/) it fails with the _"Gravatar not found!"_ error.

A tentativa de solução mais comum é:

1. Fazer uma mudança na fonte dos mapeamentos, que talvez possa resolver o problema (mas é claro que não vai).
2. Re-deploy the subgraph to [Subgraph Studio](https://thegraph.com/studio/) (or another remote Graph Node).
3. Esperar que ele se sincronize.
4. Se quebrar novamente, volte ao passo 1. Se não: Eba!

É um típico processo ordinário de debug, mas há um passo que retarda muito o processo: _3. Esperar que ele se sincronize._

Com o **subgraph forking**, podemos essencialmente eliminar este passo. Ele é algo assim:

0. Spin-up a local Graph Node with the **_appropriate fork-base_** set.
1. Faça uma mudança na fonte dos mapeamentos, que talvez possa resolver o problema.
2. Deploy to the local Graph Node, **_forking the failing subgraph_** and **_starting from the problematic block_**.
3. Se quebrar novamente, volte ao passo 1. Se não: Eba!

Agora, você deve ter duas perguntas:

1. Que fork-base???
2. Forkar quem?!

E eu respondo:

1. `fork-base` é o URL "base", tal que quando o _subgraph id_ é atrelado, o URL resultante (`<fork-base>/<subgraph-id>`) se torna um endpoint GraphQL válido para o armazenamento do subgraph.
2. Forking é fácil, não precisa se preocupar:

```bash
$ graph deploy <subgraph-name> --debug-fork <subgraph-id> --ipfs http://localhost:5001 --node http://localhost:8020
```

Aliás, não esqueça de preencher o campo `dataSources.source.startBlock` no manifest do subgraph com o número do bloco problemático, para pular a indexação de blocos desnecessários e tomar vantagem do fork!

Aqui está o que eu faço:

1. I spin-up a local Graph Node ([here is how to do it](https://github.com/graphprotocol/graph-node#running-a-local-graph-node)) with the `fork-base` option set to: `https://api.thegraph.com/subgraphs/id/`, since I will fork a subgraph, the buggy one I deployed earlier, from [Subgraph Studio](https://thegraph.com/studio/).

```
$ cargo run -p graph-node --release -- \
    --postgres-url postgresql://USERNAME[:PASSWORD]@localhost:5432/graph-node \
    --ethereum-rpc NETWORK_NAME:[CAPABILITIES]:URL \
    --ipfs 127.0.0.1:5001
    --fork-base https://api.thegraph.com/subgraphs/id/
```

2. Após vistoriar com cuidado, percebo uma discrepância nas representações de `id` usadas ao indexar `Gravatars` nos meus dois handlers. Enquanto `handleNewGravatar` o converte a um hex (`event.params.id.toHex()`), o `handleUpdatedGravatar` usa um int32 (`event.params.id.toI32()`). Assim, o `handleUpdatedGravatar` entra em pânico com o "Gravatar não encontrado!". Eu faço os dois converterem o `id` em um hex.
3. After I made the changes I deploy my subgraph to the local Graph Node, **_forking the failing subgraph_** and setting `dataSources.source.startBlock` to `6190343` in `subgraph.yaml`:

```bash
$ graph deploy gravity --debug-fork QmNp169tKvomnH3cPXTfGg4ZEhAHA6kEq5oy1XDqAxqHmW --ipfs http://localhost:5001 --node http://localhost:8020
```

4. I inspect the logs produced by the local Graph Node and, Hooray!, everything seems to be working.
5. I deploy my now bug-free subgraph to a remote Graph Node and live happily ever after! (no potatoes tho)
